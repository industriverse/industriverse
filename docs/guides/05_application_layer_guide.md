# Industriverse Application Layer Guide

## Introduction

The Application Layer is where the power of the Industriverse Framework translates into tangible business value. This layer hosts industry-specific applications built upon the foundation provided by the lower layers (Data, Core AI, Generative, Protocol). Applications in this layer leverage the framework's capabilities to address specific industrial challenges, automate processes, provide insights, and enhance operational efficiency.

## Architecture Overview

The Application Layer is designed to be modular and extensible, allowing for the development and deployment of diverse applications tailored to specific industries and use cases.

```
┌─────────────────────────────────────────────────────────────────────────┐
│                         APPLICATION LAYER                               │
│                                                                         │
│  ┌─────────────────────┐  ┌─────────────────────┐  ┌─────────────────────┐ │
│  │                     │  │                     │  │                     │ │
│  │ Industry-Specific   │  │  Cross-Industry     │  │   Application       │ │
│  │   Applications      │  │    Applications     │  │    Templates        │ │
│  │ (e.g., Mfg, Energy) │  │ (e.g., Monitoring)  │  │                     │ │
│  │                     │  │                     │  │                     │ │
│  └─────────┬───────────┘  └─────────┬───────────┘  └─────────┬───────────┘ │
│            │                        │                        │             │
│            └───────────────┬────────┴───────────────┬────────┘             │
│                            │                        │                      │
│                ┌───────────┴───────────┐  ┌─────────┴─────────┐            │
│                │                       │  │                   │            │
│                │  Application Runtime  │  │ Application Config│            │
│                │  (Execution Engine)   │  │   (Manifests)     │            │
│                │                       │  │                   │            │
│                └───────────┬───────────┘  └─────────┬─────────┘            │
│                            │                        │                      │
│  ┌─────────────────────────┴────────────────────────┴──────────────────┐   │
│  │                      Application Services                           │   │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  │   │
│  │  │             │  │             │  │             │  │             │  │   │
│  │  │ Workflow Mgmt│  │  UI Service │  │ Data Service│  │ AI Service  │  │   │
│  │  │ (n8n/Custom)│  │ (UI/UX Layer)│  │ (Data Layer)│  │ (Core AI)   │  │   │
│  │  │             │  │             │  │             │  │             │  │   │
│  │  └─────────────┘  └─────────────┘  └─────────────┘  └─────────────┘  │   │
│  │                                                                     │   │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  │   │
│  │  │             │  │             │  │             │  │             │  │   │
│  │  │ Protocol Svc│  │ Security Svc│  │ Deployment Svc│ │ Generative Svc│ │   │
│  │  │ (Prot Layer)│  │ (Sec Layer) │  │ (Deploy Layer)│ │ (Gen Layer) │ │   │
│  │  │             │  │             │  │             │  │             │  │   │
│  │  └─────────────┘  └─────────────┘  └─────────────┘  └─────────────┘  │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### Key Components

1.  **Industry-Specific Applications**: Applications designed for particular vertical markets (e.g., predictive maintenance for manufacturing, grid optimization for energy).
2.  **Cross-Industry Applications**: Common applications applicable across multiple sectors (e.g., asset tracking, general monitoring dashboards).
3.  **Application Templates**: Reusable blueprints generated by the Generative Layer for common application types.
4.  **Application Runtime**: The execution environment for applications, managing lifecycle, resources, and interactions.
5.  **Application Configuration**: Manifest files defining application structure, dependencies, and settings.
6.  **Application Services**: Interfaces providing access to the capabilities of the underlying framework layers:
    *   **Workflow Management**: Orchestrates business processes using n8n or custom engines.
    *   **UI Service**: Provides user interface components and handles user interactions via the UI/UX Layer.
    *   **Data Service**: Accesses data ingestion, processing, and storage capabilities from the Data Layer.
    *   **AI Service**: Leverages models and algorithms from the Core AI Layer.
    *   **Protocol Service**: Manages communication via MCP and A2A through the Protocol Layer.
    *   **Security Service**: Enforces security policies and manages authentication/authorization via the Security Layer.
    *   **Deployment Service**: Handles application deployment and scaling via the Deployment Operations Layer.
    *   **Generative Service**: Utilizes the Generative Layer for dynamic content, code, or UI generation within applications.

## Developing Applications

Developing applications within the Industriverse Framework typically involves leveraging the Generative Layer to bootstrap the application structure and then customizing it for specific requirements.

### Step 1: Define Application Requirements

Clearly define the application's purpose, target users, key features, data requirements, and integration points.

### Step 2: Generate Application Skeleton

Use the Generative Layer (or CLI tools built upon it) to create the basic application structure based on a template or specification.

#### Code Example: Generating an Application Skeleton

```python
from industriverse.generative.integration import ApplicationLayerIntegration

# Initialize Application Layer integration
app_integration = ApplicationLayerIntegration()

# Generate a skeleton for a Predictive Maintenance application
predictive_maintenance_app = app_integration.generate_application_skeleton(
    app_name="predictive_maintenance",
    app_type="industry_specific",
    industry="manufacturing",
    template="predictive_maintenance_dashboard",
    features=[
        "anomaly_detection",
        "remaining_useful_life_prediction",
        "maintenance_scheduling_integration",
        "real_time_monitoring",
        "historical_analysis"
    ],
    languages=["python", "typescript"],
    frameworks={"backend": "fastapi", "frontend": "react"}
)

print("Generated Predictive Maintenance Application Skeleton:")
for file_path, content in predictive_maintenance_app.items():
    print(f"- {file_path} ({len(content)} bytes)")

# The generated skeleton would include:
# - Backend API structure (FastAPI)
# - Frontend UI structure (React)
# - Data models (e.g., Equipment, SensorReadings, MaintenanceLog)
# - Basic workflow definitions (e.g., anomaly detection workflow)
# - Configuration files (manifests)
# - Dockerfiles and deployment scripts (e.g., Kubernetes manifests)
# - Basic test setup
```

### Step 3: Customize Application Logic

Implement the core business logic, integrate with specific data sources, refine AI model usage, and customize workflows.

#### Code Example: Customizing Backend Logic (Python/FastAPI)

```python
# Example: src/backend/api/endpoints/predictions.py (Generated Skeleton)
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from industriverse.core_ai.client import CoreAIClient
from industriverse.data.client import DataServiceClient
from .. import schemas, crud
from ..dependencies import get_db

router = APIRouter()
ai_client = CoreAIClient()
data_client = DataServiceClient()

@router.post("/{equipment_id}/predict_rul", response_model=schemas.RULPrediction)
def predict_remaining_useful_life(equipment_id: str, db: Session = Depends(get_db)):
    """
    Predict the Remaining Useful Life (RUL) for a piece of equipment.
    """
    # --- Customization Start ---
    # Fetch recent telemetry data for the equipment
    try:
        telemetry_data = data_client.query_telemetry(
            equipment_id=equipment_id,
            limit=100 # Fetch last 100 readings
        )
        if not telemetry_data:
            raise HTTPException(status_code=404, detail="No telemetry data found for equipment")
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to fetch telemetry data: {e}")

    # Prepare data for the RUL prediction model
    # (Specific data preparation logic depends on the model)
    prepared_data = {"features": [reading.to_dict() for reading in telemetry_data]}

    # Call the Core AI service for RUL prediction
    try:
        prediction_result = ai_client.invoke_model(
            model_id="rul_prediction_model_v1",
            input_data=prepared_data
        )
        rul_days = prediction_result.get("rul_days")
        confidence = prediction_result.get("confidence")
        if rul_days is None:
             raise ValueError("Prediction did not return 'rul_days'")
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"RUL prediction failed: {e}")

    # Store the prediction (optional)
    # crud.create_rul_prediction(db=db, equipment_id=equipment_id, rul_days=rul_days, confidence=confidence)

    return schemas.RULPrediction(equipment_id=equipment_id, rul_days=rul_days, confidence=confidence)
    # --- Customization End ---

@router.post("/{equipment_id}/detect_anomalies", response_model=list[schemas.Anomaly])
def detect_anomalies(equipment_id: str, db: Session = Depends(get_db)):
    """
    Detect anomalies in recent telemetry data.
    """
    # Fetch recent telemetry data
    telemetry_data = data_client.query_telemetry(equipment_id=equipment_id, limit=50)
    if not telemetry_data:
        raise HTTPException(status_code=404, detail="No telemetry data found")

    # Call Core AI anomaly detection model
    try:
        prepared_data = {"readings": [reading.to_dict() for reading in telemetry_data]}
        anomalies_result = ai_client.invoke_model(
            model_id="anomaly_detection_vqvae_v2",
            input_data=prepared_data
        )
        detected_anomalies = anomalies_result.get("anomalies", [])
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Anomaly detection failed: {e}")

    # Format and return anomalies
    return [schemas.Anomaly(**anomaly) for anomaly in detected_anomalies]

```

### Step 4: Develop User Interface

Build or customize the user interface using components from the UI/UX Layer and the Generative Layer. Integrate frontend components with backend APIs.

#### Code Example: Customizing Frontend Component (TypeScript/React)

```typescript
// Example: src/frontend/components/EquipmentRULCard.tsx (Generated Skeleton)
import React, { useState, useEffect } from 'react';
import { Card, CardContent, Typography, CircularProgress, Button, Box } from '@mui/material'; // Assuming Material UI from UI/UX Layer
import { apiClient } from '../services/apiClient'; // Generated API client
import { RULPrediction } from '../types'; // Generated types

interface EquipmentRULCardProps {
  equipmentId: string;
}

const EquipmentRULCard: React.FC<EquipmentRULCardProps> = ({ equipmentId }) => {
  const [prediction, setPrediction] = useState<RULPrediction | null>(null);
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<string | null>(null);

  const fetchPrediction = async () => {
    setLoading(true);
    setError(null);
    setPrediction(null);
    try {
      // --- Customization Start ---
      // Call the backend API endpoint generated in Step 3
      const response = await apiClient.post<RULPrediction>(`/predictions/${equipmentId}/predict_rul`);
      setPrediction(response.data);
      // --- Customization End ---
    } catch (err: any) {
      setError(err.response?.data?.detail || err.message || 'Failed to fetch RUL prediction');
    } finally {
      setLoading(false);
    }
  };

  // Fetch prediction on component mount
  useEffect(() => {
    fetchPrediction();
  }, [equipmentId]);

  return (
    <Card sx={{ height: '100%' }}>
      <CardContent>
        <Typography variant="h6" component="div" gutterBottom>
          Remaining Useful Life (RUL)
        </Typography>
        {loading && (
          <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: 100 }}>
            <CircularProgress />
          </Box>
        )}
        {error && (
          <Typography color="error" sx={{ mt: 2 }}>
            Error: {error}
          </Typography>
        )}
        {prediction && !loading && (
          <Box sx={{ textAlign: 'center', mt: 2 }}>
            <Typography variant="h3" component="div" color="primary">
              {prediction.rul_days !== null ? `${prediction.rul_days.toFixed(1)} days` : 'N/A'}
            </Typography>
            <Typography variant="body2" color="text.secondary">
              Confidence: {prediction.confidence !== null ? `${(prediction.confidence * 100).toFixed(1)}%` : 'N/A'}
            </Typography>
          </Box>
        )}
        <Box sx={{ mt: 3, textAlign: 'center' }}>
          <Button variant="outlined" onClick={fetchPrediction} disabled={loading}>
            Refresh Prediction
          </Button>
        </Box>
      </CardContent>
    </Card>
  );
};

export default EquipmentRULCard;
```

### Step 5: Configure Workflows

Define and configure business process workflows using the integrated workflow engine (e.g., n8n).

#### Code Example: Defining a Workflow (Conceptual n8n JSON)

```json
// Example: workflows/anomaly_alert_workflow.json (Conceptual)
{
  "name": "Anomaly Alert Workflow",
  "nodes": [
    {
      "parameters": {},
      "name": "Start",
      "type": "n8n-nodes-base.start",
      "typeVersion": 1,
      "position": [ 250, 300 ]
    },
    {
      "parameters": {
        "path": "webhooks/anomaly", // Webhook triggered by anomaly detection service
        "options": {}
      },
      "name": "Webhook Trigger",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [ 450, 300 ],
      "webhookId": "unique-webhook-id-for-anomaly"
    },
    {
      "parameters": {
        "url": "={{ $json.body.api_endpoint }}/equipment/{{ $json.body.equipment_id }}", // Fetch equipment details
        "options": {}
      },
      "name": "Get Equipment Details",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 1,
      "position": [ 650, 200 ]
    },
    {
      "parameters": {
        "conditions": { // Check severity of the anomaly
          "boolean": [
            {
              "value1": "={{ $json.body.severity }}",
              "operation": "equal",
              "value2": "critical"
            }
          ]
        }
      },
      "name": "Is Critical?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [ 850, 300 ]
    },
    {
      "parameters": {
        "subject": "Critical Anomaly Detected: {{ $node['Get Equipment Details'].json.name }} (ID: {{ $json.body.equipment_id }})",
        "to": "critical-alerts@example.com",
        "text": "A critical anomaly of type '{{ $json.body.anomaly_type }}' was detected at {{ $json.body.timestamp }} for equipment {{ $node['Get Equipment Details'].json.name }}.\n\nDetails: {{ $json.body.details }}\nLocation: {{ $node['Get Equipment Details'].json.location }}"
      },
      "name": "Send Critical Email",
      "type": "n8n-nodes-base.emailSend", // Assumes Email node configured
      "typeVersion": 1,
      "position": [ 1050, 200 ]
    },
    {
      "parameters": {
        "subject": "Warning: Anomaly Detected: {{ $node['Get Equipment Details'].json.name }} (ID: {{ $json.body.equipment_id }})",
        "to": "warning-alerts@example.com",
        "text": "A warning anomaly of type '{{ $json.body.anomaly_type }}' was detected at {{ $json.body.timestamp }} for equipment {{ $node['Get Equipment Details'].json.name }}."
      },
      "name": "Send Warning Email",
      "type": "n8n-nodes-base.emailSend",
      "typeVersion": 1,
      "position": [ 1050, 400 ]
    },
    {
        "parameters": { // Create a maintenance ticket via API call
            "url": "http://maintenance-system/api/tickets",
            "method": "POST",
            "bodyParameters": {
                "equipmentId": "={{ $json.body.equipment_id }}",
                "description": "Critical anomaly detected: {{ $json.body.anomaly_type }} ",
                "priority": "high"
            },
            "options": {}
        },
        "name": "Create Maintenance Ticket",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 1,
        "position": [ 1250, 200 ]
    }
  ],
  "connections": {
    "Start": { "main": [ [ { "node": "Webhook Trigger", "type": "main" } ] ] },
    "Webhook Trigger": { "main": [ [ { "node": "Get Equipment Details", "type": "main" } ] ] },
    "Get Equipment Details": { "main": [ [ { "node": "Is Critical?", "type": "main" } ] ] },
    "Is Critical?": {
        "main": [ // Output 0 (true)
            [ { "node": "Send Critical Email", "type": "main" } ],
            // Output 1 (false)
            [ { "node": "Send Warning Email", "type": "main" } ]
        ]
    },
    "Send Critical Email": { "main": [ [ { "node": "Create Maintenance Ticket", "type": "main" } ] ] }
    // Warning email might not create a ticket, or could create a lower priority one
  }
}
```

### Step 6: Configure and Deploy

Define the application manifest, configure dependencies, and use the Deployment Operations Layer to deploy the application to the target environment (e.g., Kubernetes).

#### Code Example: Application Manifest (`manifests/predictive_maintenance_app.yaml`)

```yaml
apiVersion: industriverse.io/v1
kind: Application
metadata:
  name: predictive-maintenance
  version: 1.0.0
  industry: manufacturing
spec:
  description: Predictive Maintenance application for manufacturing equipment.
  type: industry_specific
  owner: maintenance_team@example.com
  components:
    - name: backend-api
      type: service
      layer: application # Runs within the app layer context
      source: ./src/backend
      language: python
      framework: fastapi
      build:
        dockerfile: ./src/backend/Dockerfile
      deploy:
        replicas: 2
        port: 8000
        resources:
          requests: { cpu: "200m", memory: "512Mi" }
          limits: { cpu: "1", memory: "1Gi" }
      dependencies:
        - service: data-service # From Data Layer
          access: read-write
        - service: core-ai-service # From Core AI Layer
          models: ["rul_prediction_model_v1", "anomaly_detection_vqvae_v2"]
        - service: protocol-service # From Protocol Layer (if needed)
          protocols: ["mcp"]
        - service: security-service # From Security Layer
          policy: manufacturing_secure
    - name: frontend-ui
      type: service
      layer: application
      source: ./src/frontend
      language: typescript
      framework: react
      build:
        dockerfile: ./src/frontend/Dockerfile
        build_args:
          API_ENDPOINT: "/api/predictive-maintenance" # Relative path for ingress
      deploy:
        replicas: 2
        port: 3000
        resources:
          requests: { cpu: "100m", memory: "256Mi" }
          limits: { cpu: "500m", memory: "512Mi" }
      dependencies:
        - service: backend-api # Internal dependency
  workflows:
    - name: anomaly-alert-workflow
      source: ./workflows/anomaly_alert_workflow.json
      engine: n8n # Specifies the workflow engine
      trigger: webhook # Triggered via webhook
      enabled: true
  data_models: # References models defined in Data Layer or app-specific
    - name: Equipment
    - name: SensorReadings
    - name: MaintenanceLog
    - name: RULPrediction
    - name: Anomaly
  ai_models: # References models from Core AI Layer
    - name: rul_prediction_model_v1
    - name: anomaly_detection_vqvae_v2
  ui_views: # References UI components/views from UI/UX Layer or app-specific
    - name: EquipmentDashboard
    - name: MaintenanceScheduleView
    - name: AnomalyListView
  protocols: # Protocols used by the application
    - name: mcp
      version: 1.0.0
      usage: internal_communication
  security_policy: manufacturing_secure # References policy from Security Layer
  deployment_target: kubernetes # Target environment from Deployment Ops Layer
  configuration:
    # Application-specific configuration values
    anomaly_threshold: 0.95
    rul_prediction_interval_hours: 24
    maintenance_api_key: "{{ secrets.MAINTENANCE_API_KEY }}" # Reference secrets
```

## Integration with Other Layers

The Application Layer acts as the primary consumer of services from all other layers:

-   **Data Layer**: Consumes data access, storage, and processing services.
-   **Core AI Layer**: Utilizes AI models for prediction, analysis, and decision-making.
-   **Generative Layer**: Leverages templates and generation capabilities for bootstrapping and dynamic content.
-   **Protocol Layer**: Uses MCP and A2A for communication between application components and external agents.
-   **Workflow Automation Layer**: Integrates with n8n or other engines to orchestrate business processes.
-   **UI/UX Layer**: Consumes UI components and services to build user interfaces.
-   **Security & Compliance Layer**: Adheres to security policies and uses authentication/authorization services.
-   **Deployment Operations Layer**: Relies on deployment, scaling, and monitoring services.
-   **Overseer System**: Provides data and events for monitoring, receives commands for control.

## Best Practices

1.  **Modularity**: Design applications as modular components.
2.  **Leverage the Framework**: Utilize services from lower layers instead of reimplementing functionality.
3.  **Use Generative Layer**: Bootstrap applications using templates and generation tools.
4.  **Configuration Management**: Manage application configuration via manifests.
5.  **Industry Focus**: Tailor applications to specific industry needs and terminology.
6.  **User-Centric Design**: Focus on the user experience, leveraging the UI/UX Layer.
7.  **Security by Design**: Integrate security considerations from the start.
8.  **Test Thoroughly**: Implement unit, integration, and end-to-end tests.
9.  **Monitor Performance**: Utilize the Overseer System for monitoring application health and performance.

## Troubleshooting

-   **Deployment Failures**: Check application manifests, Dockerfiles, Kubernetes configurations, and Deployment Operations Layer logs.
-   **Integration Errors**: Verify service endpoints, authentication credentials, and protocol compatibility with dependent layers.
-   **Performance Issues**: Analyze resource utilization, check database queries, optimize AI model calls, and consult Overseer System metrics.
-   **Workflow Problems**: Debug workflows in the n8n UI or check logs for custom workflow engines.
-   **UI Glitches**: Inspect browser console logs, check API responses, and verify UI component props and state.

## Next Steps

-   Explore the [Protocol Layer Guide](06_protocol_layer_guide.md) for details on inter-component communication.
-   See the [Workflow Automation Layer Guide](07_workflow_automation_layer_guide.md) for more on building complex workflows.
-   Consult the [UI/UX Layer Guide](08_ui_ux_layer_guide.md) for advanced UI development.

## Related Guides

-   [Generative Layer Guide](04_generative_layer_guide.md)
-   [Deployment Operations Layer Guide](10_deployment_operations_layer_guide.md)
-   [Overseer System Guide](11_overseer_system_guide.md)
-   [Integration Guide](12_integration_guide.md)

